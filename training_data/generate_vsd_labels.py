"""Generate frame labels for Violent Scenes Dataset

VSD provided by Technicolor at http://www.technicolor.com/en/innovation/scientific-community/scientific-data-sharing/violent-scenes-dataset

Citations:
    - C.H. Demarty, C. Penet, M. Soleymani, G. Gravier. VSD, a public dataset
      for the detection of violent scenes in movies: design, annotation,
      analysis and evaluation. In Multimedia Tools and Applications, May 2014.
    - C.H. Demarty, B. Ionescu, Y.G. Jiang, and C. Penet. Benchmarking Violent
      Scenes Detection in movies. In Proceedings of the 2014 12th International
      Workshop on Content-Based Multimedia Indexing (CBMI), 2014.
    - M. Sjöberg, B. Ionescu, Y.G. Jiang, V.L. Quang, M. Schedl and C.H. Demarty.
      The MediaEval 2014 Affect Task: Violent Scenes Detection. In Working Notes
      Proceedings of the MediaEval 2014 Workshop, Barcelona, Spain (2014).
    - C.H. Demarty, C. Penet, G. Gravier and M. Soleymani. A benchmarking campaign
      for the multimodal detection of violent scenes in movies. In Proceedings
      of the 12th international conference on Computer Vision – Volume Part III
      (ECCV’12), Andrea Fusiello, Vittorio Murino, and Rita Cucchiara (Eds),
      Col. Part III. Springer Verlag, Berlin.

This file is really only concerned with taking the annotations found in
VSD_2014_December_official_release/YouTube-gen/annotations and generating more
complete labels for each frame in each video.

Current annotations have at each line a range of frames for which violence was
detected
For example, 0egEFZq2Y28.txt:
    591 640
    713 762
    828 1651
    1754 1798
    2198 2385
    2713 4423
    4544 4636

Instead, full frame labels are desired such that each line of the file represents
the label for that frame.
For instance:
    0 |
    0 |=> no violence detected for frames 1-3
    0 |
    1    |
    1    |
    1    |=> violence detected for frames 4-8
    1    |
    1    |
    ...
"""

def get_args():
    '''Get command-line arguments to this script

    Output:
        input: string; directory to find current video annotations
        counts: string; path to find _frame_counts.txt
        output: string; directory to save generated frame labels
    '''

    import argparse
    import os

    class ValidatePathAction(argparse.Action):
        '''Validate given directory or filepaths'''
        def __call__(self, parser, namespace, values, option_string=None):

            # Output directory => may need to be created
            if option_string:
                os.makedirs(values, exist_ok=True)

            # Validate all paths
            if not os.path.exists(values):
                parser.error('Path "{}" does not exist!'.format(values))

            setattr(namespace, self.dest, values)

    parser = argparse.ArgumentParser(description='Generate frame labels for VSD')
    parser.add_argument('input', type=str, action=ValidatePathAction,
                        help='Directory containing current video annotations.')
    parser.add_argument('counts', type=str, action=ValidatePathAction,
                        help='File containing total frame counts for each video, i.e. _frame_counts.txt generated by split_videos_to_frames.py')
    parser.add_argument('-o', type=str, default='.', dest='output', action=ValidatePathAction,
                        help='Directory to save new frame labels. Defaults to current working directory.')

    return parser.parse_args()

def get_frame_counts(file_path):
    '''Get frame counts for each video file

    Expects file at file_path to contain the following format at each line:
        video_name [\t] frame_count

    Input:
        file_path: string; path to _frame_counts.txt (from split_videos_to_frames.py)

    Output:
        counts: dict; [filename]: counts
    '''

    counts = dict()

    with open(file_path, 'r') as f:
        for line in f:
            data = line[:-1].split('\t')
            counts[data[0]] = int(data[1])

    return counts

def get_violence_ranges(file_path):
    '''Get frame ranges of violence for a video file

    Assumes annotation file follows the follow format at each line:
        range_begin [space] range_end

    Input:
        file_path: string; path to video annotation

    Output:
        ranges: list; [(begin, end), (begin, end), ...]
    '''

    ranges = []

    with open(file_path, 'r') as f:
        for line in f:
            data = line[:-1].split()
            ranges.append((int(data[0]), int(data[1])))

    return ranges

def main():
    '''Main script logic'''

    import glob
    import os

    args = get_args()
    counts = get_frame_counts(args.counts)
    cur_files = glob.glob(os.path.join(args.input, '*.txt'))

    for f in cur_files:
        base = os.path.splitext(os.path.basename(f))[0]
        ranges = get_violence_ranges(f)
        begin, end = ranges.pop(0) if len(ranges) else (0, 0)

        with open(os.path.join(args.output, '{}_labels.txt'.format(base)), 'w') as label_f:
            for i in range(1, counts[base] + 1):
                if i < begin:
                    label_f.write('0\n')
                elif i >= begin and i <= end:
                    label_f.write('1\n')
                else:
                    label_f.write('0\n')
                    if len(ranges):
                        begin, end = ranges.pop(0)

if __name__ == '__main__':
    main()
